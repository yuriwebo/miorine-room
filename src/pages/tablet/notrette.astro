---
import BaseLayout from "../../layouts/BaseLayout.astro";
import questionImage from '../../images/console-question.svg';
import '../../styles/notrette.css';

const geneMap: Record<string, string> = {
  // 小写
  a: "AAA",
  b: "AAC",
  c: "AAG",
  d: "AAT",
  e: "ACA",
  h: "ACT",
  i: "AGA",
  l: "AGT",
  m: "ATA",
  n: "ATC",
  o: "ATG",
  r: "CAC",
  s: "CAG",
  t: "CAT",
  u: "CCA",
  w: "CCG",
  y: "CGA",

  // 大写
  H: "GTA",
  I: "GTC",
  M: "TAC",

  //特殊字符
  " ": "CGG",
  ",": "CTA",
  ".": "CGT",
  "?": "CTG"
};

//将一段文字转换成基因序列组合
const textToGeneSequence = (text: string) => {
  return text
    .split("")
    .map(char => geneMap[char] || "") //若没有对应基因序列就忽略
    .join("");
}

const decodedAnswer = "I will always be attached to you, Miorine.";
const encodedAnswer = textToGeneSequence(decodedAnswer);
---
<BaseLayout>
  <div class="content notrette-container">
    <h2>
      <span class="title">Emergency Console</span>
    </h2>
    <div class="question-container">
      <img src={questionImage.src} alt="console问题">
    </div>
    <div class="console-container">
      <!-- 终端输入模拟 -->
      <div class="console">
        <span class="label">Please enter</span>
        <div class="editor-container">
          <span class="prompt">&gt;</span>
          <div
            class="editor"
            contenteditable="plaintext-only"
            spellcheck="false"
            autofocus="true">{encodedAnswer}</div>
          <div class="custom-caret"></div>
        </div>
      </div>
      <!-- 错误信息 -->
      <div class="output fail hide">
        <p class="error-txt">
          <span class="bracket left">[</span>
          {"ERROR".split("").map(letter => (
            <span>{letter}</span>
          ))}
          <span class="bracket right">]</span>
        </p>
        <p>Authentication failed</p>
      </div>
      <!-- 正确信息 -->
      <div class="output success hide">
        <p>
          {decodedAnswer.split(" ").map(word => (
            <span>{word}</span>
          ))}
        </p>
        <p>Authenticated</p>
      </div>
      <!-- happy ending信息 -->
      <div class="output ending hide">
        <p>I love you. From Mom.</p>
      </div>
    </div>
    <div class="footnote">
      <span>QuietZero System Control Console</span>
    </div>
  </div>
</BaseLayout>

<script>
  const consoleDiv = document.querySelector(".console") as HTMLDivElement;
  const editor = consoleDiv.querySelector('.editor') as HTMLDivElement;
  const customCaret = consoleDiv.querySelector('.custom-caret') as HTMLDivElement;

  //期待值为初始值
  const expected = editor.textContent;

  // 记录英文行高基准，避免 Firefox / 一些浏览器中文字符导致光标上浮
  // 当整行都是英文字符时，记录 rect.height 基准，以后出现中文时，用它来修正光标垂直偏移
  let baseRectHeight: number | null = null;

  // 宽字符正则和判断函数
  const WIDE_CHAR_RE =
    /[\u1100-\u115F\u2E80-\uA4CF\uAC00-\uD7A3\uF900-\uFAFF\uFE10-\uFE6F\uFF00-\uFF60\uFFE0-\uFFE6]/;

  // 判断一个字符是否是全角 / CJK 宽字符
  const isWideChar = (ch: string) => {
    return WIDE_CHAR_RE.test(ch);
  };

  // 更新自定义光标位置
  const updateCustomCaret = () => {
    // 如果 editor 不是激活状态，就隐藏光标
    if (document.activeElement !== editor) {
      customCaret.classList.remove('active');
      return;
    }

    // 获取当前 selection
    const sel = window.getSelection();
    if (!sel?.rangeCount) return; // 没有选区就直接返回

    // 克隆当前光标所在的 range（避免直接改原始 range）
    const range = sel.getRangeAt(0).cloneRange();
    // 确保光标在 editor 内
    if (!editor.contains(range.startContainer)) return;

    // 光标收缩到插入点（不要选中文本）
    range.collapse(false);

    // 获取光标对应的矩形（客户端坐标）
    const rect = range.getClientRects()[0];
    if (!rect) return; // 如果没矩形（比如空行），就直接返回

    // 获取 editor 的母容器位置，用来计算相对偏移
    const container = editor.parentElement!;
    const containerRect = container.getBoundingClientRect();

    // 光标相对于容器左上角的坐标
    const x = rect.left - containerRect.left + container.scrollLeft;
    const y = rect.top - containerRect.top + container.scrollTop;

    // =============================
    // 文本信息处理
    // =============================
    let text = '';     // 当前节点的文本
    let nextChar = ''; // 光标后面那个字符

    const node = range.startContainer;
    if (node.nodeType === Node.TEXT_NODE) {
      text = node.textContent || '';
      nextChar = text[range.startOffset] || '';
    }

    // =============================
    // 光标宽度判断（只看后字符）
    // =============================
    // 原理：英文/数字 → 瘦光标；中文/全角 → 宽光标
    const caretWidth = isWideChar(nextChar) ? '1.7ch' : '1ch';

    // =============================
    // 光标垂直偏移修正
    // =============================
    let visualOffsetY = 0;

    if (text) {
      // 整行是否有宽字符
      const hasWide = WIDE_CHAR_RE.test(text);

      if (!hasWide) {
        // 整行纯英文 → 记录基准高度
        baseRectHeight = rect.height;
      } else if (baseRectHeight !== null) {
        // 出现宽字符 → 用高度差修正
        // 浏览器中文 rect.height 往上扩，取一半压回去
        visualOffsetY = (rect.height - baseRectHeight) / 2;
      }
    }

    customCaret.style.width = caretWidth;
    customCaret.style.left = `${x}px`;
    customCaret.style.top = `${y + visualOffsetY}px`;
    customCaret.classList.add('active');
  };

  editor.addEventListener('focus', () => {
    customCaret.classList.add('active');
    updateCustomCaret();
  });

  editor.addEventListener('blur', () => {
    customCaret.classList.remove('active');
  });

  ['input', 'keyup', 'keydown', 'scroll'].forEach(event => {
    editor.addEventListener(event, updateCustomCaret);
  });

  // 移动光标器时更新自定义光标位置
  document.addEventListener('selectionchange', () => {
    if (document.activeElement === editor) {
      updateCustomCaret();
    }
  });

  window.addEventListener('resize', updateCustomCaret);

  // 页面加载完成后，聚焦 editor 并初始化光标
  document.addEventListener('DOMContentLoaded', () => {
    editor.focus();
    updateCustomCaret();
  });

  // 判断输入值，显示output
  editor.addEventListener('keydown', (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      const answer = editor.textContent;

      if (answer === expected) {
        showSuccessOutput();
      } else {
        showFailOutput();
      }
    }
  });

  const showFailOutput = () => {
    const failOutput = document.querySelector(".fail") as HTMLDivElement;
    const fail1 = failOutput.firstElementChild;
    const fail2 = failOutput.lastElementChild;

    editor.contentEditable = "false"; //防止console反应
    failOutput.classList.remove("hide");

    // 1秒后，fail1和fail2开始淡出，fail2淡出比较慢
    setTimeout(() => {
      fail1?.classList.add("fade-out");
      fail2?.classList.add("fade-out");
    }, 1000);

    // fail2淡出结束后
    fail2?.addEventListener('transitionend', () => {
      // 隐藏容器
      failOutput.classList.add("hide");
      // 清理子元素状态
      fail1?.classList.remove("fade-out");
      fail2?.classList.remove("fade-out");
      // 重置editor
      editor.contentEditable = "true";
      editor.focus();
    }, { once: true });
  };

  const showSuccessOutput = () => {
    const successOutput = document.querySelector(".success") as HTMLDivElement;
    const success1 = successOutput.firstElementChild;
    const success2 = successOutput.lastElementChild;
    const heOutput = document.querySelector(".ending") as HTMLDivElement;
    const heText = heOutput.firstElementChild;

    editor.contentEditable = "false"; //防止console反应

    successOutput.classList.remove("hide");
    success1?.classList.add("fade-in");
    // success1淡入结束后
    success1?.addEventListener('animationend', () => {
      // 先停顿一会后，success2出现并闪烁2次
      setTimeout(() => {
        success2?.classList.add("flash-twice");
      }, 300);
    }, { once: true });

    success2?.addEventListener('animationend', () => {
      // 先停顿一会后，heOutput淡入
      setTimeout(() => {
        heOutput.classList.remove("hide");
        heOutput.classList.add("show");
      }, 300);
    }, { once: true });

    heOutput?.addEventListener('animationend', () => {
      // heOutput淡入结束后，heText淡入
      heText?.classList.add("replay");
    }, { once: true });

    heText?.addEventListener('animationend', () => {
      // heText淡入后，先停顿一会
      setTimeout(() => {
        // 隐藏容器
        heOutput.classList.add("hide");
        successOutput.classList.add("hide");
        // 清理子元素状态
        success1?.classList.remove("fade-in");
        success2?.classList.remove("flash-twice");
        heOutput?.classList.remove("show");
        heText?.classList.remove("replay");
        // 重置editor
        editor.contentEditable = "true";
        editor.focus();
      }, 600);
    }, { once: true });
  };
</script>